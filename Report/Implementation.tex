\chapter{Implementation}\label{chap:Implementation}

In this section, we will discuss the implementation of each of the components of libbind. The workflow/usage is covered separately in Chapter~\ref{chap:Workflow}. Any major deviations from what has been covered in Design and Architecture will be highlighted.

\section{Binary Abstraction Layer}

the binary abstraction layer originally acted as a bridge between the components and the target file. essentially, libbind encapsulates a binary file in an internal structure called a bin\_file. a bin\_file contains two important elements: the bfd abstraction of a binary and its corresponding cfg (which is generated by the static analysis engine). in general, when a component needs to read information about the binary, it will read from the generated cfg. as we have seen, writing to the binary is equivalent to modifying the cfg. after a change to the cfg occurs, this change is flushed to the underlying binary through the bfd object. this was the original concept and is illustrated in figure...

FIGURE GOES HERE

unfortunately, libbfd is not designed for patching. with libbfd, it is possible to open an existing file with read-only access or to open a \emph{new and empty} file with write-only access. this is fine for tools such as ld and objcopy because the file is written in a single pass, but unsuitable for our usage. it is possible, but very awkward to patch a file through libbfd. figure............ illustrates the steps that are required to patch a file through libbfd:

FIGURE GOES HERE

the patching works through a series of steps:

- open the target binary with read access. decompose the binary and extract all the section and section contents.
- create a new writable binary (starts off empty). reconstruct the target binary in this binary by copying the extracted sections
- perform the patch
- flush changes to disk

the first two stages are essentially what objcopy does. our implementation of static patching re-uses the objcopy code for the decomposition and reconstruction stage. there are two drawbacks with this method:

1. the part of the code re-used from objcopy was around 1.5k LOC
2. the implementation required data from the binary that was not part of the generalised bfd abstract format. in order to obtain this information, the code relied on a dependency with the file format and ended up calling functions in libelf.

given these two disadvantages, there is no reason to use bfd to perform this task. the method is overly complicated and more error-prone simply because of the amount of code that has to be written to perform a patch. since there is already a dependency on libelf, we may as well use libelf ourselves directly. in terms of the binary abstraction layer, this means that writes do not go through the bfd object held in bin\_file but are simply flushed straight to the disk file as shown in figure .............

FIGURE GOES HERE
 
the binary abstraction layer code was rewritten to use libelf where the same result can be achieved in < 100 LOC. the method is fairly intuitive and the concept is visualised in figure ............ in libelf, similarly to bfd, an executable contains a set of sections in which both code and data can reside. it is possible to map a virtual address to a physical file offset through the following steps:

- parse the section header of the executable with libelf. this allows us to obtain a set of sections. importantly, for each section, libelf can tell us three things:
1. the size of the section (section size)
2. the address that section will be based at when the executable on disk is loaded into memory (section base address)
3. the disk offset of the section (section disk offset)
- by iterating through the section information extracted in the previous step, it is possible to find out what section an arbitrary virtual memory address (say X) is contained in. the offset of the virtual memory address into the section can be calculated by finding the difference between X and the section base address
- the disk offset of X can hence be calculated by ( section disk offset + (X - section base address) )

this process allows us to map an arbitrary virtual memory address to its corresponding disk file offset. this offset can then be patched with regular c file IO functions such as fopen/fseek/fwrite/fclose.

fortunately the architecture of libbind was designed such that a change in the implementation of one component (even if that is the binary abstraction layer) should not impact the other components. the downside is that a lot of time was lost writing the bfd patch code, only to have it thrown out in favour of another method. however, this was unavoidable as the documentation did not make it clear how difficult the implementation of patching would be using libbfd. the lack of clear documentation is a widely recognised drawback to libbfd and the required steps were only discovered by reading through objcopy source.

\section{Static Analysis Engine}

as discussed in earlier sections, the static analysis engine requires a 

disasm engine builds on top of several abstractions. detailed diagram of disasm engine and how it works above libbfd and libopcodes. perhaps some justification for why we chose to use these
%
%in practice, the disassembler engine is responsible for parsing and translating the strings received from libopcodes and storing that information in its internal semantic representation (bf\_insn, bf\_basic\_blk). bf\_func can be identified from three ways only:
%1) if it is the target of a call site
%2) if it corresponds to an address identified as a bf\_sym
%3) if the user defined it as a root for cfg generation and explicitly stated it is a function (cfg analysis and generation is covered in depth in...)
%
%further information such as size of symbols (which tells us size of function) is available because we are parsing the symbol table directly from libelf.
%
%quirks of libopcodes disassembler such as how it passes us the instruction parts (mnemonic, operands, separator) as strings! we build a finite state machine which allows us to 
%
%we can draw finite state machine in diagram here
%
%binary\_file
%
%within a binary\_file, there are 2 levels of code representation. firstly we have bf\_basic\_blk which represents a basic\_block as defined in architecture.
%
%binary\_file is composed of a CFG of bf\_basic\_blk objects. during the process of cfg generation and after it completes, we add extra information. i.e., bf\_func 'labels'
%
%bf\_func
%
%implementation of CFG analysis and generation...
%
%epilogue relocation

\section{Object File Injector}


%
%distribution and documentation
%
%automake which we use to deal with library dependencies (libelf, libbfd, libopcodes, libkern).
%
% and doxygen
%
%WORKFLOW

%\chapter{Project Plan}

%If time permits, the most desirable extension is to add dynamic detouring to the library. %We would implement some form of runtime detouring and provide users with the option to %choose between both methods. Another smaller extension which would also be useful is to %allow the library to be invocable through the command-line as well as through the API (as %seen with ELFsh).