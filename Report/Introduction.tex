\chapter{Introduction}\label{chap:Introduction}

The ability to modify the behaviour of an executable is a powerful aspect of software development that is often not fully exploited. While editing the source code of executables is a routine practice in software development, there are many cases where there is either no access to source code or it is inconvenient to perform modifications at that level.

One such example is the situation where a bug is displayed only in the production environment. The classical approach is to recompile the code with integrated logging and to reproduce the bug. This allows a developer to isolate and gather information about the circumstances under which the bug occurs and to `catch it in the act'. Unfortunately, this is often impractical if the system under test is already in production. Furthermore, when deployment is a heavyweight process, giving a user a logged or debug build can be cumbersome and disruptive.

An ideal solution would be to have some form of injectable logging which can be performed by an end-user in a manner that resembles the weaving of aspects in aspect-oriented programming. That is, the cross-cutting behaviour of logging becomes modularised. In our exemplary scenario, the user would run some tool which patches logging functionality to the target system, either altering it or duplicating it and altering the copy. The following example illustrates what such a tool would allow us to achieve. Given the target system:

\begin{lstlisting}[language=C,caption={Target Process}]
#include <stdlib.h>
#include <time.h>

int func1(int num)
{
  return 10/num;
}

int main(void)
{
  srand(time(NULL));

  for(int i=0; i<5; i++) {
    func1(rand() % 5);
  }

  return EXIT_SUCCESS;
}
\end{lstlisting}

In this circumstance, \emph{rand() \% 5} will occassionally evaluate to 0 leading to \emph{func1} performing a divide-by-zero causing the FPU to signal a hardware exception. The tool should allow a user to determine whether \texttt{func1} was invoked, and if so when, how many times and with what parameters/return values.

As a concrete real-world example, the issue tracker of \emph{lighttpd} illustrates several cases with the exact scenario we are describing\footnote{Bug \#1278 (http://redmine.lighttpd.net/issues/1278)}\footnote{Bug \#1116 (http://redmine.lighttpd.net/issues/1116)}\footnote{Bug \#605 (http://redmine.lighttpd.net/issues/605)}. The tool would make it possible to provide users with a piece of code which would be injected into the binary. The tool would then patch the binary to make calls to the injected code which would collect the information necessary to hunt down the bug. Observation through tracing is only a single use of a tool capable of injecting arbitrary code into a binary. Execution detouring is not a new concept and previous example usages include:

\begin{enumerate}
 \item \textbf{Debugging} - \emph{IF} is a Windows tool instrumenting \emph{Microsoft Detours} into a stealthy debugger. The tool provides the emulation of breakpoints through execution detouring rather than using standard implementations of software and hardware breakpoints\cite{IF}. IF provides users with the ability to target an executable and mine information on the data/code flow, order of execution and parameters/return values of functions. 
 \item \textbf{Profiling} - Detouring has been used extensively for profiling and tracing. Notable implementations include \emph{Valgrind}, \emph{pixie} and \emph{qpt}\cite{qpt,qpt_pixie,valgrind}, which inject instrumentation to record execution frequencies and trace memory references.
 \item \textbf{Interception} - \emph{NOZZLE} is a tool which performs runtime heap-spraying detection\cite{nozzle} through the use of detouring. Once again, it is implemented on top of \emph{Microsoft Detours}. The tool intercepts calls to the memory manager in the Mozilla Firefox browser.
\end{enumerate}

We want to be able to perform execution detouring on Linux x86-32 and x86-64, where related work is relatively sparse. Essentially, Microsoft Detours exists as the de facto standard for execution detouring on the Windows platform, whereas there is no such tool for Linux. Some existing solutions on Linux appeared to be potentially promising but were later dismissed for reasons such as discontinued development or having unnecessarily complex interfaces which were difficult to use. The latter is certainly true of several solutions which provide limited support for detouring but are unpopular, mainly because they are large toolchains simply incorporating detouring as one of many provided features. For this reason, their usage is cumbersome and their API complicated (compared to Microsoft Detours).

\section{Requirements}
\label{sec:Requirements}

We intend to produce a lightweight and dedicated library for Linux x86-32 and x86-64 which provides execution detouring functionality for existing binaries where source code is unavailable. The intended library will \emph{(F1)} allow users to override arbitrary functions with user defined routines. Furthermore, the library must  \emph{(F2)} provide the capability to extend the semantics of functions in the original code through trampolining (see \emph{section \ref{sec:trampoline}}). These features work at the procedural level, but the library should also \emph{(F3)} expose an interface that allows modification (insertion, modification and removal of instructions) at the basic-block level. The library will provide access to these features through a simple and clean interface which abstracts implementation details.

In order to be convenient to a user, the library will perform analysis on the target binary to enumerate routines and the basic blocks within them. This analysis should take advantage of any available symbol information. To effectively represent the target, \emph{(F4)} a control flow graph should be generated in the form of a directed graph. A visitor pattern is ideal for traversing such a graph:

\begin{lstlisting}[language=C,caption={API for traversal of control flow graph},label={lst:VisitorPattern}]
bf_enum_basic_blk(struct bin_file * bf, void (*handler)(struct bin_file *, struct bf_basic_blk *, void *), void * param);
\end{lstlisting}

\emph{Listing \ref{lst:VisitorPattern}} illustrates an example of the proposed API for modifying basic blocks. The \texttt{handler} passed into the function will be called as each basic block in the binary is traversed. As is common with the usage of C callbacks, the user is able to provide a parameter which will be passed to the handler function for each invocation. Multiple values can be passed by aggregating them into a \emph{struct} and passing a pointer to it. The API will provide similar variants for handling the enumeration and traversal of procedures and instructions. We will provide another set of functions which give \emph{(F5)} direct access to the generated control flow graph. This will allow people to build further on top of the library, such as creating a tool to analyse the differences between two binaries by examining and comparing their respective control flow graphs.

One specific use of the library is within an existing project, which has its own runtime environment. This means an optimal solution would \emph{(F6)} require no extra runtime requirements or separate environment to be distributed.

We plan to \emph{(F7)} re-use as much existing functionality as possible to simplify the development and future maintenance. This means making optimal use of relevant libraries that we find.

\section{Report Structure}

We start by taking a deeper look into some of the technical specificities of related concepts in Background (Chapter~\ref{chap:Background}). This will help with understanding what considerations we must bear in mind. This will also enable us to examine related work more critically and ultimately justify planning and design decisions we make. After this, Related Work (Chapter~\ref{chap:Related}) will discuss in further detail the existing work that has been done in this field. We will present our findings and discuss why we assessed existing solutions to be unsuitable. As well as this, we will look at what we can take away from these solutions.

In Design (Chapter~\ref{chap:Design}), we will review the functional requirements defined in Requirements (Section~\ref{sec:Requirements}) and discuss our intended approach and the proposed solution. The architecture of the solution is discussed and a high-level view of its constituent components presented in Architecture (Chapter~\ref{chap:Architecture}). The actual implementation is discussed in Implementation (Chapter~\ref{chap:Implementation}), where the details about how the library works from a technical aspect are revealed. This section will also cover the optimisations that were made to the library. Any major deviations between the original design and the actual implementation as discussed in Deviations from Design (Chapter~\ref{chap:Deviations}).

Workflow (Chapter~\ref{chap:Workflow}) gives the general usage and workflow with the library. The aim is to show the expressibility and ease-of-use of the library interface compared to existing software.

The final solution must work robustly and not just for toy examples. The library contains a test suite which is discussed in Testing (Chapter~\ref{chap:Testing}). The Evaluation (Chapter~\ref{chap:Evaluation}) benchmarks the success of the project. We also discuss the limitations of the library. The Conclusion (Chapter~\ref{chap:Conclusion}) concludes the project and also discusses future work.